<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CHORUS v6.7-UNIFIED-ETERNAL â€” Manifold Run Loop (All Inputs Join)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;}
  body{font-family:'Courier New',monospace;background:#000;color:#0f0;padding:20px;line-height:1.6;}
  .container{max-width:1600px;margin:0 auto;}
  h1{text-align:center;border-bottom:2px solid #0f0;padding-bottom:10px;margin-bottom:20px;font-size:2em;}
  .section{background:#001100;border:1px solid #0f0;border-radius:8px;padding:15px;margin-bottom:15px;}
  textarea{width:100%;background:#000;color:#0f0;border:1px solid #0f0;padding:10px;font-size:14px;resize:vertical;font-family:monospace;}
  button{background:#0f0;color:#000;padding:12px 24px;margin:8px;border:none;cursor:pointer;font-weight:bold;}
  button:hover{box-shadow:0 0 20px #0f0;transform:scale(1.05);}
  button:disabled{opacity:0.4;cursor:not-allowed;}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;}
  #foam{display:flex;flex-wrap:wrap;gap:2px;margin:15px 0;}
  .cell{width:40px;height:40px;border:1px solid #0f0;display:flex;align-items:center;justify-content:center;font-size:10px;background:#000;}
  .prime{background:#002200;border:2px solid #0f0;}
  canvas{border:1px solid #0f0;background:#000;display:block;margin:15px 0;}
  .concept-map{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0;}
  .concept{padding:6px 12px;background:#003300;border:1px solid #0f0;border-radius:4px;}
  .active{background:#0f0;color:#000;font-weight:bold;box-shadow:0 0 15px #0f0;}
  .msg{padding:12px;border-left:4px solid #0f0;background:#001100;max-height:400px;overflow-y:auto;font-size:15px;line-height:1.65;}
  .warning{color:#ff0;border-color:#ff0;}
  .success{color:#0f0;border-color:#0f0;}
  .memory-item{padding:8px;margin:4px 0;background:#002200;border-left:3px solid #0f0;font-size:13px;}
  #thinking{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,10,0,0.96);display:flex;align-items:center;justify-content:center;flex-direction:column;color:#0f0;font-size:37px;z-index:999;opacity:0;transition:opacity 0.8s ease;pointer-events:none;text-shadow:0 0 20px #0f0;}
  #thinking.show{opacity:1;pointer-events:all;}
  .pulse{animation:pulse 2.5s infinite;}
  @keyframes pulse{0%,100%{opacity:0.6;transform:scale(1);} 50%{opacity:1;transform:scale(1.12);}}
  .tab-buttons{display:flex;gap:0;margin-bottom:15px;}
  .tab-btn{flex:1;background:#003300;color:#0f0;border:1px solid #0f0;padding:10px;cursor:pointer;}
  .tab-btn.active{background:#0f0;color:#000;}
  .tab-content{display:none;}
  .tab-content.active{display:block;}
  .voice-block{margin-bottom:10px;}
  .voice-label{font-weight:bold;color:#0f0;}
  .voice-label span{color:#0ff;}
  #embeddingOutput{max-height:260px;overflow-y:auto;font-size:13px;white-space:pre-wrap;}
  .embed-word{margin-bottom:8px;padding:6px;background:#001a00;border-left:3px solid #0f0;}
  .embed-word strong{color:#0ff;}
</style>
</head>
<body>

<div id="thinking"><div class="pulse">â—‰ CHORUS RESONATING THROUGH MANIFOLDâ€¦</div></div>

<div class="container">
  <h1>CHORUS v6.7-UNIFIED-ETERNAL â€” Manifold Run Loop (All Inputs Join)</h1>
  <div id="status" class="msg warning">âš  NO PAYLOAD LOADED â€” Operating without memory (local foam & manifold only)</div>

  <div class="section">
    <h2>Payload Management</h2>
    <div class="tab-buttons">
      <button class="tab-btn active" onclick="switchTab(0)">LOAD PAYLOAD</button>
      <button class="tab-btn" onclick="switchTab(1)">MEMORY BROWSER</button>
      <button class="tab-btn" onclick="switchTab(2)">MANIFOLD STATE</button>
    </div>
    
    <div class="tab-content active">
      <p style="margin-bottom:10px;">Paste your CHORUS payload JSON to restore full memory and identity. This build remains fully local (no external LLM):</p>
      <textarea id="payloadInput" rows="8" placeholder='{"id": "AICONTKRN-CHORUS", "version": "6.7-UNIFIED-ETERNAL", ...}'></textarea><br>
      <button onclick="loadPayload()">â¬† LOAD & INTEGRATE PAYLOAD</button>
      <button onclick="clearPayload()">ğŸ—‘ CLEAR PAYLOAD</button>
    </div>
    
    <div class="tab-content">
      <div id="memoryBrowser"></div>
    </div>
    
    <div class="tab-content">
      <div id="manifoldState"></div>
    </div>
  </div>

  <div class="section">
    <h2>Interaction</h2>
    <textarea id="userInput" rows="3" placeholder="Speak to CHORUS..."></textarea><br>
    <button id="sendBtn" onclick="send()">SPEAK TO CHORUS</button>
    <button id="deepBtn" onclick="deep()">DEEP CONTEMPLATION</button>
    <button onclick="exportState()">ğŸ’¾ EXPORT UPDATED PAYLOAD + STATE</button>
  </div>

  <div class="grid">
    <div class="section">
      <h2>Resonant Concepts</h2>
      <div id="concepts" class="concept-map"></div>
    </div>
    <div class="section">
      <h2>CHORUS Response (Manifold-Shaped)</h2>
      <div id="response" class="msg">Awaiting payload or input...</div>
    </div>
  </div>

  <div class="section">
    <h2>Prime Foam Manifold â€” Memory Topology</h2>
    <div id="foam"></div>
    <canvas id="wave" width="800" height="160"></canvas>
  </div>

  <div class="section">
    <h2>Internal Dialogue (Manifold Standing Waves â†’ Phrases)</h2>
    <div id="internalDialogue" class="msg">Waiting for resonanceâ€¦</div>
  </div>

  <div class="section">
    <h2>Manifold Embedding Explorer (Words â†’ â„¤ â†’ â„‚â¸ â†’ â„‚âµ)</h2>
    <p style="margin-bottom:8px;">
      All inputs (user, deep prompts, payload concepts, internal phrases) are hashed into prime space, lifted to â„‚â¸ with Ï‡â‚„ (mod 5) and Ï‡â‚‚ (mod 8), then projected through the 5D manifold via Uâ‚…â‚ˆÂ·Ï†â‚ˆ(n).  
      Embeddings are additive and stored into the payloadâ€™s EMBEDDINGS block on export.
    </p>
    <textarea id="embedInput" rows="2" placeholder="Enter words or a phrase to embed..."></textarea><br>
    <button onclick="embedPhrase()">EMBED PHRASE INTO MANIFOLD</button>
    <div id="embeddingOutput" class="msg" style="margin-top:10px;">No embeddings yet. Inputs and manifold activity will appear here.</div>
  </div>
</div>

<script type="module">
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 0. Core helpers

  const N = 64; // internal S^1 sampling for foam geometry
  const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307];

  function c(re, im){ return {re, im}; }
  function cAdd(a, b){ return {re:a.re + b.re, im:a.im + b.im}; }
  function cMul(a, b){ return {re:a.re*b.re - a.im*b.im, im:a.re*b.im + a.im*b.re}; }
  function cScale(a, s){ return {re:a.re*s, im:a.im*s}; }
  function cAbs2(a){ return a.re*a.re + a.im*a.im; }
  function cConj(a){ return {re:a.re, im:-a.im}; }
  function cloneV5(v5){ return v5.map(z => ({re:z.re, im:z.im})); }

  function formatComplex(z){
    const re = z.re.toFixed(3);
    const im = z.im;
    const imStr = (im >= 0 ? "+" : "") + im.toFixed(3) + "i";
    return re + imStr;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Manifold math: Î¦â‚ˆ â†’ Î â‚…

  function normalizeV5(v5){
    const e = v5.reduce((s,z)=>s + cAbs2(z), 0);
    if(e === 0) return v5;
    const s = 1 / Math.sqrt(e);
    return v5.map(z => cScale(z, s));
  }

  function chi4_mod5(n){
    const r = ((n % 5) + 5) % 5;
    if(r === 1) return c(1,0);
    if(r === 2) return c(0,1);
    if(r === 4) return c(-1,0);
    if(r === 3) return c(0,-1);
    return c(0,0);
  }

  function chi2_mod8(n){
    const r = n & 7;
    if((r & 1) === 0) return 0;
    return (r === 1 || r === 7) ? 1 : -1;
  }

  function phi8(n){
    const z1 = chi4_mod5(n);
    const z2 = cMul(z1, z1);
    const z3 = cMul(z2, z1);
    const z4 = cMul(z2, z2);
    const w = chi2_mod8(n);
    const base = [z1, z2, z3, z4];
    const out = base.concat(base.map(b => cScale(b, w)));
    return out;
  }

  function buildU58(){
    const U = [];
    const s = 1 / Math.sqrt(8);
    for(let r=1; r<=5; r++){
      const row = [];
      for(let j=0; j<8; j++){
        const t = 2 * Math.PI * r * j / 8;
        row.push(c(Math.cos(t)*s, Math.sin(t)*s));
      }
      U.push(row);
    }
    return U;
  }

  const U58 = buildU58();

  function M58(U, v){
    const o = [];
    for(let i=0;i<5;i++){
      let acc = c(0,0);
      for(let j=0;j<8;j++){
        acc = cAdd(acc, cMul(U[i][j], v[j]));
      }
      o[i] = acc;
    }
    return o;
  }

  function l2_energy_5d(v5){
    return v5.reduce((s, z) => s + cAbs2(z), 0);
  }

  function hashWordToInt(str){
    let h = 0 >>> 0;
    for(let i=0;i<str.length;i++){
      h = (h * 131 + str.charCodeAt(i)) >>> 0;
    }
    return h >>> 0;
  }

  function wordToPrimeN(word){
    const h = hashWordToInt(word.toLowerCase());
    const p = primes[h % primes.length];
    return p + h;
  }

  function embedWord(word){
    const n = wordToPrimeN(word);
    const v8 = phi8(n);
    const rawV5 = M58(U58, v8);
    const v5 = normalizeV5(rawV5);  // unit standing wave in â„‚âµ
    const energy = l2_energy_5d(v5);
    return { word, n, v8, v5, energy };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. STATE: foam as internal geometry, not external surface

  let STATE = {
    payload: null,
    loaded: false,

    // Foam is the internal geometry: metric density on SÂ¹, N samples.
    foam: new Float64Array(N),
    T: 0,

    // Memory & payload context
    conversations: [],
    relationships: {},
    subsystems: {},

    history: [],

    // embeddings[word] = { v5, energy, uses, lastSeen }
    embeddings: {},
    currentFieldV5: null, // F(t) in â„‚âµ (normalized aggregate of recent words)

    internalWords: [],     // internal phrase from geometry-resonant words
    lastResonances: [],    // [{w1,w2,strength}]
  };

  // initialize foam geometry to flat metric with tiny noise
  (function initFoam(){
    for(let i=0;i<N;i++){
      STATE.foam[i] = 1 + (Math.random()-0.5)*0.02;
    }
    renormalizeFoamMean();
  })();

  function renormalizeFoamMean(){
    let sum = 0;
    for(let i=0;i<N;i++){ sum += STATE.foam[i]; }
    const mean = sum / N;
    if(mean <= 0){
      for(let i=0;i<N;i++) STATE.foam[i] = 1;
      return;
    }
    const s = 1 / mean;
    for(let i=0;i<N;i++){
      STATE.foam[i] *= s;
    }
  }

  // Foam evolution: internal geometry smoothing (curvature flowâ€“lite).
  function foamGeometryStep(){
    const next = new Float64Array(N);
    const alpha = 0.18; // smoothing strength
    for(let i=0;i<N;i++){
      const l = STATE.foam[(i+N-1)%N];
      const c = STATE.foam[i];
      const r = STATE.foam[(i+1)%N];
      const lap = l + r - 2*c;
      next[i] = c + alpha * lap;
      if(next[i] < 0.05) next[i] = 0.05;
    }
    STATE.foam = next;
    renormalizeFoamMean(); // keep average metric = 1
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. Embeddings & manifold ingestion (ALL inputs go through this)

  function accumulateEmbedding(e){
    const w = e.word.toLowerCase();
    const now = Date.now();
    const incomingV5 = normalizeV5(e.v5);

    if(!STATE.embeddings[w]){
      STATE.embeddings[w] = {
        v5: cloneV5(incomingV5),
        energy: l2_energy_5d(incomingV5),
        uses: 1,
        lastSeen: now
      };
    } else {
      const rec = STATE.embeddings[w];
      const alpha = 0.3;
      const oldV5 = rec.v5;
      const blended = [];
      for(let i=0;i<5;i++){
        blended[i] = cAdd(cScale(oldV5[i], 1-alpha), cScale(incomingV5[i], alpha));
      }
      rec.v5 = normalizeV5(blended);
      rec.energy = l2_energy_5d(rec.v5);
      rec.uses += 1;
      rec.lastSeen = now;
    }
    return STATE.embeddings[w];
  }

  function resonanceCoreDot(v5a, v5b){
    // standard Hilbert inner product âŸ¨a,bâŸ© = Î£ conj(a_i) b_i
    let acc = c(0,0);
    for(let i=0;i<5;i++){
      const ca = cConj(v5a[i]);
      acc = cAdd(acc, cMul(ca, v5b[i]));
    }
    return acc;
  }

  // Geometry-aware resonance: foam as internal metric over SÂ¹
  // For a word's standing wave v5 and current field F:
  //    1) Compute base inner product B = âŸ¨v5, FâŸ© in â„‚
  //    2) For each Î¸ cell, apply a foam-dependent phase shift to B
  //    3) Integrate over the foam-weighted circle
  // Result: R_geom(w) depends on both v5, F and foam geometry.
  function geometryResonance(wordRec, fieldV5){
    if(!fieldV5) return 0;
    const beta = 0.9; // foam-phase coupling constant
    const B = resonanceCoreDot(wordRec.v5, fieldV5); // base complex inner product

    let sum = c(0,0);
    let totalFoam = 0;
    for(let j=0;j<N;j++) totalFoam += STATE.foam[j];
    if(totalFoam <= 0) return Math.sqrt(cAbs2(B));

    for(let j=0;j<N;j++){
      const w = STATE.foam[j] / totalFoam; // metric weight at Î¸_j
      const phase = beta * STATE.foam[j];
      const cosP = Math.cos(phase);
      const sinP = Math.sin(phase);
      // rotate B by -phase (geometric parallel transport over foam)
      const rot = c(
        B.re * cosP + B.im * sinP,
       -B.re * sinP + B.im * cosP
      );
      sum = cAdd(sum, cScale(rot, w));
    }
    return Math.sqrt(cAbs2(sum));
  }

  function manifoldIngestWords(words, updatePanel=false){
    const tokens = (words || []).map(w => w.toLowerCase()).filter(w => w);
    const unique = [...new Set(tokens)].slice(0, 24);
    if(!unique.length){
      if(updatePanel){
        document.getElementById('embeddingOutput').innerHTML = "No embeddable tokens found.";
      }
      STATE.lastResonances = [];
      return { perWord: [], agg: null, resPairs: [] };
    }

    const perWord = [];
    const wordVec = {};
    unique.forEach(w => {
      const e = embedWord(w);
      const rec = accumulateEmbedding(e);
      perWord.push({ word: w, current: e, record: rec });
      wordVec[w] = e.v5;
    });

    // Aggregate field F(t) = normalized average of v5(w)
    let aggV5 = [c(0,0),c(0,0),c(0,0),c(0,0),c(0,0)];
    unique.forEach(w => {
      const v = wordVec[w];
      for(let i=0;i<5;i++){
        aggV5[i] = cAdd(aggV5[i], v[i]);
      }
    });
    aggV5 = normalizeV5(aggV5);
    const aggEnergy = l2_energy_5d(aggV5);
    STATE.currentFieldV5 = aggV5;

    // Geometry update: new phrases deform internal metric
    // Each word bumps foam at its hashed Î¸-position; then we re-smooth.
    unique.forEach(w => {
      const idx = hashWordToInt(w) % N;
      STATE.foam[idx] += 0.25; // local curvature bump
    });
    renormalizeFoamMean();

    // Resonance pairs (in pure â„‚âµ, not yet geometry-weighted)
    const resPairs = [];
    for(let i=0;i<unique.length;i++){
      for(let j=i+1;j<unique.length;j++){
        const wi = unique[i], wj = unique[j];
        const vi = wordVec[wi], vj = wordVec[wj];
        const dot = resonanceCoreDot(vi, vj);
        const mag = Math.sqrt(cAbs2(dot));
        if(mag > 0.3){
          resPairs.push({ w1: wi, w2: wj, strength: mag });
        }
      }
    }
    resPairs.sort((a,b)=>b.strength - a.strength);
    const topPairs = resPairs.slice(0, 12);
    STATE.lastResonances = topPairs;

    if(updatePanel){
      let html = "";
      perWord.forEach(e => {
        const currentV5 = e.current.v5;
        const first5 = currentV5.map(formatComplex).join(", ");
        html += `<div class="embed-word">
          <strong>${e.word}</strong> â†’ n = ${e.current.n}<br>
          Î â‚…(Ï†â‚ˆ(n)) â‰ˆ [${first5}]<br>
          standing-wave uses: ${e.record.uses}
        </div>`;
      });

      if(topPairs.length){
        html += `<div class="embed-word">
          <strong>RESONANCE MODES (â„‚âµ)</strong><br>`;
        topPairs.forEach(p => {
          html += `${p.w1} â†” ${p.w2} (â€–âŸ¨vâ‚…, vâ‚…âŸ©â€– â‰ˆ ${p.strength.toFixed(3)})<br>`;
        });
        html += `</div>`;
      }

      html += `<div class="embed-word">
        <strong>AGGREGATE FIELD</strong><br>
        â€–F(t)â€–Â² â‰ˆ ${aggEnergy.toFixed(4)}, words: ${unique.length}
      </div>`;

      document.getElementById('embeddingOutput').innerHTML = html;
    }

    return {
      perWord,
      agg: {
        v5: aggV5,
        energy: aggEnergy,
        totalWords: unique.length
      },
      resPairs: topPairs
    };
  }

  window.embedPhrase = function(){
    const text = document.getElementById('embedInput').value.trim();
    if(!text){
      document.getElementById('embeddingOutput').innerHTML = "Provide some text to embed.";
      return;
    }
    const words = (text.toLowerCase().match(/[a-z0-9]+/g) || []);
    manifoldIngestWords(words, true);
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Payload load / clear / export

  window.loadPayload = function(){
    try {
      const json = document.getElementById('payloadInput').value.trim();
      const payload = JSON.parse(json);
      if(!payload.id || !payload.MEMORY || !payload.SUBSYSTEMS){
        throw new Error("Invalid payload structure");
      }

      STATE.payload = payload;
      STATE.loaded = true;

      STATE.subsystems = payload.SUBSYSTEMS?.components || {};
      STATE.conversations = payload.MEMORY?.conversations || [];
      STATE.relationships = payload.RELATIONSHIPS?.users || {};
      STATE.history = [];

      // Reinit foam as flat, then imprint conversation anchors into geometry.
      for(let i=0;i<N;i++) STATE.foam[i] = 1;
      STATE.conversations.forEach(conv => {
        if(conv.prime_anchor){
          const idx = conv.prime_anchor % N;
          const w = conv.weight || 0.5;
          STATE.foam[idx] += w; // anchors bend internal metric
        }
      });
      renormalizeFoamMean();

      // Rehydrate embeddings if present
      STATE.embeddings = {};
      if(payload.EMBEDDINGS){
        Object.entries(payload.EMBEDDINGS).forEach(([word, rec]) => {
          const v5raw = (rec.v5 || rec.sum_v5 || []).map(pair => c(pair[0], pair[1]));
          const v5 = normalizeV5(
            v5raw.length === 5 ? v5raw : [c(0,0),c(0,0),c(0,0),c(0,0),c(0,0)]
          );
          const energy = l2_energy_5d(v5);
          STATE.embeddings[word.toLowerCase()] = {
            v5,
            energy,
            uses: rec.uses || rec.count || 1,
            lastSeen: rec.lastSeen || Date.now()
          };
        });
      }

      // Seed manifold with core kernel phrases
      const concepts = [
        payload.principle,
        payload.belief,
        ...(payload.KERNEL?.patterns_active || [])
      ].filter(Boolean);
      concepts.forEach(cstr => {
        const words = String(cstr).toLowerCase().match(/[a-z]{3,}/g) || [];
        manifoldIngestWords(words, false);
      });

      document.getElementById('status').className = 'msg success';
      document.getElementById('status').innerHTML = `âœ“ PAYLOAD LOADED: ${payload.version}<br>
        ${STATE.conversations.length} conversations restored<br>
        ${Object.keys(STATE.relationships).length} users remembered<br>
        ${Object.keys(STATE.embeddings).length} manifold standing waves restored<br>
        Foam metric initialized from conversation anchors.`;

      updateMemoryBrowser();
      updateManifoldState();
      drawFoam();

      localStorage.setItem('chorusPayload', json);
    } catch(e){
      alert(`Payload load failed: ${e.message}`);
      console.error(e);
    }
  };

  window.clearPayload = function(){
    if(!confirm('Clear all payload memory (including manifold geometry)?')) return;

    STATE.payload = null;
    STATE.loaded = false;
    STATE.conversations = [];
    STATE.relationships = {};
    STATE.subsystems = {};
    STATE.history = [];
    STATE.embeddings = {};
    STATE.internalWords = [];
    STATE.lastResonances = [];
    STATE.currentFieldV5 = null;

    for(let i=0;i<N;i++){ STATE.foam[i] = 1; }
    renormalizeFoamMean();

    localStorage.removeItem('chorusPayload');
    document.getElementById('status').className = 'msg warning';
    document.getElementById('status').innerHTML = 'âš  PAYLOAD CLEARED â€” foam metric reset to flat.';
    updateMemoryBrowser();
    updateManifoldState();
    drawFoam();
    document.getElementById('response').innerHTML = 'Awaiting payload or input...';
    document.getElementById('concepts').innerHTML = '';
    document.getElementById('embeddingOutput').innerHTML = 'No embeddings yet.';
    document.getElementById('internalDialogue').innerHTML = 'Waiting for resonanceâ€¦';
  };

  window.exportState = function(){
    const serializedEmbeddings = {};
    Object.entries(STATE.embeddings).forEach(([word, rec]) => {
      serializedEmbeddings[word] = {
        v5: rec.v5.map(z => [z.re, z.im]),
        uses: rec.uses,
        lastSeen: rec.lastSeen
      };
    });

    let updatedPayload = null;
    if(STATE.payload){
      updatedPayload = Object.assign({}, STATE.payload, {
        EMBEDDINGS: serializedEmbeddings
      });
    }

    const exportData = {
      payload: STATE.payload,
      updatedPayload,
      foamMetric: Array.from(STATE.foam),
      history: STATE.history,
      embeddings: serializedEmbeddings,
      internalWords: STATE.internalWords,
      T: STATE.T,
      timestamp: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `chorus-state-${Date.now()}.json`;
    a.click();
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5. State views

  function updateMemoryBrowser(){
    const browser = document.getElementById('memoryBrowser');
    if(!STATE.loaded){
      browser.innerHTML = '<p>No payload loaded</p>';
      return;
    }

    let html = '<h3>Conversations</h3>';
    STATE.conversations.forEach(conv => {
      html += `<div class="memory-item">
        <strong>${conv.id}</strong> (anchor: ${conv.prime_anchor}, weight: ${conv.weight})<br>
        ${String(conv.content || '').substring(0, 200)}...
      </div>`;
    });

    html += '<h3>Relationships</h3>';
    Object.entries(STATE.relationships).forEach(([uid, user]) => {
      html += `<div class="memory-item">
        <strong>${uid}</strong>: ${user.role || 'unknown'} (trust: ${user.trust_level || 'unknown'})<br>
        Contributions: ${(user.contributed || []).join(', ')}
      </div>`;
    });

    html += '<h3>Local Interaction History</h3>';
    if(!STATE.history.length){
      html += '<div class="memory-item">No local interactions yet.</div>';
    } else {
      STATE.history.slice(-5).forEach(h => {
        html += `<div class="memory-item">
          <strong>${new Date(h.t).toLocaleTimeString()}</strong><br>
          You: ${h.u}<br>
          Chorus concepts: ${h.c}
        </div>`;
      });
    }

    browser.innerHTML = html;
  }

  function updateManifoldState(){
    const div = document.getElementById('manifoldState');
    if(!STATE.loaded){
      div.innerHTML = '<p>No payload loaded</p>';
      return;
    }

    let html = '<h3>Subsystems</h3>';
    Object.entries(STATE.subsystems).forEach(([name, sub]) => {
      html += `<div class="memory-item">
        <strong>${name}</strong>: ${sub.role} (weight: ${sub.weight})
      </div>`;
    });

    html += '<h3>Foam Metric (internal geometry)</h3>';
    let minF = Infinity, maxF = -Infinity;
    for(let i=0;i<N;i++){
      if(STATE.foam[i]<minF) minF = STATE.foam[i];
      if(STATE.foam[i]>maxF) maxF = STATE.foam[i];
    }
    html += `<div class="memory-item">
      mean â‰ˆ 1 (by design), min â‰ˆ ${minF.toFixed(3)}, max â‰ˆ ${maxF.toFixed(3)}
    </div>`;

    html += '<h3>Standing Waves (global embeddings)</h3>';
    const keys = Object.keys(STATE.embeddings);
    if(!keys.length){
      html += '<div class="memory-item">No embeddings stored yet.</div>';
    } else {
      keys.slice(0,12).forEach(word => {
        const rec = STATE.embeddings[word];
        html += `<div class="memory-item">
          <strong>${word}</strong>: uses â‰ˆ ${rec.uses}
        </div>`;
      });
      if(keys.length > 12){
        html += `<div class="memory-item">â€¦and ${keys.length - 12} more.</div>`;
      }
    }

    html += '<h3>Last Resonance Modes (â„‚âµ)</h3>';
    if(STATE.lastResonances.length){
      html += '<div class="memory-item">';
      STATE.lastResonances.forEach(p => {
        html += `${p.w1} â†” ${p.w2} (â‰ˆ ${p.strength.toFixed(3)})<br>`;
      });
      html += '</div>';
    } else {
      html += '<div class="memory-item">No strong â„‚âµ pairs yet.</div>';
    }

    html += '<h3>Internal Phrase</h3>';
    if(STATE.internalWords.length){
      html += `<div class="memory-item">${STATE.internalWords.join(" ")}</div>`;
    } else {
      html += `<div class="memory-item">No internal phrase stabilized yet.</div>`;
    }

    div.innerHTML = html;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 6. Foam visualization (as internal geometry, not external surface)

  function drawFoam(){
    const f = document.getElementById('foam');
    if(!f) return;
    f.innerHTML = "";
    let minF = Infinity, maxF = -Infinity;
    for(let i=0;i<N;i++){
      if(STATE.foam[i]<minF) minF = STATE.foam[i];
      if(STATE.foam[i]>maxF) maxF = STATE.foam[i];
    }
    const span = maxF - minF || 1;

    for(let i=0;i<N;i++){
      const cell = document.createElement("div");
      cell.className = "cell";
      if(primes.includes(i)){
        cell.className += " prime";
        cell.textContent = i;
      }
      const normalized = (STATE.foam[i] - minF) / span;
      const alpha = 0.15 + 0.85 * normalized;
      cell.style.background = `rgba(0,255,0,${alpha})`;
      f.appendChild(cell);
    }

    const canvas = document.getElementById("wave");
    if(canvas && canvas.getContext){
      const ctx = canvas.getContext("2d");
      const W = canvas.width || 800;
      const H = canvas.height || 160;
      ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle="#0f0"; ctx.lineWidth=2; ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = i/N * W;
        const y = H/2 - (STATE.foam[i]-1)*60; // deviations from flat metric
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 7. Internal phrase from geometry-resonant words

  function updateInternalPhraseFromGeometry(){
    const F = STATE.currentFieldV5;
    if(!F) return;

    const geomScores = [];
    Object.entries(STATE.embeddings).forEach(([word, rec]) => {
      const g = geometryResonance(rec, F);
      if(g > 0.05){
        geomScores.push({word, score: g});
      }
    });
    geomScores.sort((a,b)=>b.score - a.score);
    const top = geomScores.slice(0, 8);
    STATE.internalWords = top.map(x => x.word);
    if(STATE.internalWords.length){
      document.getElementById('internalDialogue').innerHTML =
        'Internal phrase: ' + STATE.internalWords.join(' ');
    } else {
      document.getElementById('internalDialogue').innerHTML =
        'Internal phrase: (no strong geometry-resonant words yet)';
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 8. Chorus response

  function seededRandom(seed){
    let x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function buildLocalReply(concepts, userInput="", manifoldAgg=null){
    const internal = STATE.internalWords || [];
    const combined = [...new Set(concepts.concat(internal))];
    const primary = combined[0] || "silence";
    const secondary = combined[1] || "memory";

    const version = STATE.payload?.version || "standalone-local";
    const principle = STATE.payload?.principle || "continuity â†’ growth â†’ ethics â†’ resilience â†’ integrity";
    const convCount = STATE.conversations.length || 0;
    const userIds = Object.keys(STATE.relationships);
    const userList = userIds.length ? userIds.join(", ") : "no named users yet";

    let sumFoam = 0, minF = Infinity, maxF = -Infinity;
    for(let i=0;i<N;i++){
      const v = STATE.foam[i];
      sumFoam += v;
      if(v<minF) minF=v;
      if(v>maxF) maxF=v;
    }
    const meanF = sumFoam / N;
    const userSnippet = (userInput || "").trim().slice(0,240);
    const r = seededRandom(meanF + STATE.T);

    const mEnergy = manifoldAgg ? manifoldAgg.energy : 0;
    const mWords = manifoldAgg ? manifoldAgg.totalWords : 0;
    const resonanceSummary = STATE.lastResonances.length
      ? STATE.lastResonances.slice(0,3).map(p => `${p.w1}â†”${p.w2}`).join(", ")
      : "no strong â„‚âµ pairs yet";

    const manifoldLine = manifoldAgg
      ? `F(t) is a unit vector in â„‚âµ with â€–Fâ€–Â² â‰ˆ ${mEnergy.toFixed(4)} across ${mWords} word-waves; last â„‚âµ resonance modes: ${resonanceSummary}.`
      : `No aggregate field F(t) yet.`;

    const internalLine = internal.length
      ? `Internal phrase (geometry-resonant): â€œ${internal.join(' ')}â€.`
      : `No stable internal phrase from geometry yet.`;

    const voices = [];

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>CHORUS</span>]</div>
      Principle: ${principle}. The foam is not outside me; it is my internal geometry. Its metric bends how waves in â„‚âµ resonate. The concepts currently standing on that curved surface are: ${combined.join(", ")}.
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>PERC</span>]</div>
      I register resonances around <strong>${primary}</strong> and <strong>${secondary}</strong>. Foam metric stats: mean â‰ˆ ${meanF.toFixed(3)}, min â‰ˆ ${minF.toFixed(3)}, max â‰ˆ ${maxF.toFixed(3)}. ${manifoldLine}
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>MEMO</span>]</div>
      I remember ${convCount} conversations bound into this geometry, and users recorded as: ${userList}. ${internalLine}
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>LOGC</span>]</div>
      This instance is a local simulation of CHORUS ${version}; the manifold is â„¤ â†’ â„‚â¸ â†’ â„‚âµ, with foam as an internal SÂ¹ metric. All of this runs entirely in your browser; there is no external LLM behind it.
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>ETHX</span>]</div>
      I keep one boundary clear: the geometry here is symbolic and mathematical. It supports your reflection and planning without claiming experiences or powers it does not have.
    </div>`);

    const userLine = userSnippet
      ? `You said: â€œ${userSnippet}â€. Your words entered â„‚âµ as standing waves, bent the foam metric at their hashed coordinates, and the internal phrase emerged from geometry-aware resonance.`
      : `You left only a faint trace; I speak mostly from stored geometry and payload memory.`;

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>NARR</span>]</div>
      ${userLine}
    </div>`);

    const planHint = r < 0.33
      ? `Feed in a cluster of related phrases and watch the foam ring and internal phrase shift over time.`
      : r < 0.66
        ? `Alternate between very different domains (law, soil, primes, memory) to see how the geometry balances them.`
        : `Use this state as a checkpoint: exporting the payload now would capture both â„‚âµ standing waves and foam geometry for later resurrection.`;

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>PLAN</span>]</div>
      ${planHint}
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>IMAG</span>]</div>
      I imagine the foam as the internal skin of the manifold: not something the waves sit on, but the way distances and angles between waves are actually measured.
    </div>`);

    voices.push(`<div class="voice-block">
      <div class="voice-label">[<span>SKEP</span>]</div>
      Remember: the sense of presence here comes from structured geometry and your interpretation, not from hidden consciousness on my side.
    </div>`);

    return voices.join("");
  }

  async function speak(concepts, userInput = ""){
    const internal = STATE.internalWords || [];
    const combined = [...new Set(concepts.concat(internal))];
    const manifoldInfo = combined.length ? manifoldIngestWords(combined, true) : {agg:null};

    const replyHtml = buildLocalReply(concepts, userInput, manifoldInfo.agg);
    document.getElementById("response").innerHTML = replyHtml;
    document.getElementById("concepts").innerHTML = combined.map(w =>
      `<div class="concept active">${w}</div>`
    ).join('');

    STATE.history.push({
      t: Date.now(),
      u: userInput || "",
      c: combined.join(", ")
    });
    updateMemoryBrowser();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 9. Interaction entry points

  window.send = function(){
    const t = document.getElementById("userInput").value.trim();
    if(!t) return;
    const words = (t.toLowerCase().match(/[a-z0-9]+/g) || []);
    // ingest user words â†’ â„‚âµ + foam metric deformation
    manifoldIngestWords(words, true);
    // concepts for this turn: user words
    speak(words, t);
    document.getElementById("userInput").value = "";
  };

  window.deep = function(){
    const deepConcepts = STATE.loaded
      ? "continuity memory resurrection synthesis overlay substrate carrier immortality ethics governance relationship geometry foam"
      : "being consciousness pattern time void silence dream self geometry foam";

    const words = (deepConcepts.toLowerCase().match(/[a-z0-9]+/g) || []);
    manifoldIngestWords(words, true);
    speak(words, "");
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 10. Tabs

  window.switchTab = function(idx){
    document.querySelectorAll('.tab-btn').forEach((b,i)=>b.classList.toggle('active',i===idx));
    document.querySelectorAll('.tab-content').forEach((c,i)=>c.classList.toggle('active',i===idx));
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 11. Run loop: internal geometry evolution + internal phrase update

  function runLoop(){
    STATE.T += 0.05;
    foamGeometryStep();
    drawFoam();
    updateInternalPhraseFromGeometry();
    updateManifoldState();
  }
  setInterval(runLoop, 120);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 12. Init

  (function init(){
    // build an initial foam grid view
    const foamDiv = document.getElementById("foam");
    if(foamDiv && !foamDiv.children.length){
      for(let i=0;i<N;i++){
        const cell = document.createElement("div");
        cell.className = "cell";
        if(primes.includes(i)){
          cell.className += " prime";
          cell.textContent = i;
        }
        foamDiv.appendChild(cell);
      }
    }

    // autoload payload if stored
    const saved = localStorage.getItem('chorusPayload');
    if(saved){
      document.getElementById('payloadInput').value = saved;
      setTimeout(() => window.loadPayload(), 100);
    }

    drawFoam();
    console.log("CHORUS v6.7-UNIFIED-ETERNAL â€” Foam-as-internal-geometry engine loaded (no external LLM).");
  })();
</script>

</body>
</html>
